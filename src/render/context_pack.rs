//! Context pack Markdown rendering

use crate::domain::{Chunk, FileInfo, ScanStats};
use crate::utils::{format_with_commas, read_file_safe};
use chrono::Utc;
use serde_json::Value as JsonValue;
use std::collections::HashMap;
use std::path::Path;

#[allow(clippy::too_many_arguments)]
pub fn render_context_pack(
    root_path: &Path,
    files: &[FileInfo],
    chunks: &[Chunk],
    stats: &ScanStats,
    tree: &str,
    manifest_info: &HashMap<String, JsonValue>,
    task_query: Option<&str>,
    include_timestamp: bool,
) -> String {
    let mut out = String::new();

    // â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    out.push_str(&format!(
        "# Repository Context Pack: {}\n\n",
        root_path.file_name().and_then(|n| n.to_str()).unwrap_or("repo")
    ));
    if include_timestamp {
        out.push_str(&format!(
            "> Generated by repo-to-prompt on {}\n",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
        ));
    } else {
        out.push_str("> Generated by repo-to-prompt\n");
    }
    // Summary line: Files | Chunks | Size (matches Python _render_header)
    out.push_str(&format!(
        "> Files: {} | Chunks: {} | Size: {} bytes\n",
        stats.files_included,
        chunks.len(),
        format_with_commas(stats.total_bytes_included)
    ));
    if let Some(task) = task_query.filter(|q| !q.trim().is_empty()) {
        out.push_str(&format!("> Task Context: {}\n", task.trim()));
    }
    out.push_str("\n---\n\n");

    let mut contribution_files: Vec<&FileInfo> = files
        .iter()
        .filter(|f| {
            f.tags.contains("contribution") || f.relative_path.starts_with(".github/workflows/")
        })
        .collect();
    contribution_files.sort_by(|a, b| a.relative_path.cmp(&b.relative_path));
    if !contribution_files.is_empty() {
        out.push_str("## ğŸ¤ Contribution Guide\n\n");
        out.push_str("**Key contribution files:**\n");
        for file in contribution_files.iter().take(10) {
            out.push_str(&format!("- `{}`\n", file.relative_path));
        }

        let mut suggested_commands: Vec<String> = Vec::new();
        for file in &contribution_files {
            if let Ok((content, _)) = read_file_safe(&file.path, Some(10_000), None) {
                for line in content.lines() {
                    let trimmed = line.trim();
                    if trimmed.is_empty() || trimmed.len() > 120 {
                        continue;
                    }
                    if [
                        "cargo test",
                        "cargo build",
                        "npm test",
                        "pnpm test",
                        "yarn test",
                        "pytest",
                        "go test",
                        "make test",
                        "just test",
                    ]
                    .iter()
                    .any(|needle| trimmed.contains(needle))
                    {
                        suggested_commands.push(trimmed.to_string());
                    }
                }
            }
        }
        suggested_commands.sort();
        suggested_commands.dedup();
        if !suggested_commands.is_empty() {
            out.push_str("\n**Build/Test commands (detected):**\n");
            for command in suggested_commands.iter().take(8) {
                out.push_str(&format!("- `{}`\n", command));
            }
        }

        let workflow_files: Vec<&FileInfo> = contribution_files
            .iter()
            .copied()
            .filter(|f| f.relative_path.starts_with(".github/workflows/"))
            .collect();
        if !workflow_files.is_empty() {
            out.push_str("\n**How changes are reviewed (CI/workflows):**\n");
            for workflow in workflow_files.iter().take(5) {
                out.push_str(&format!("- `{}`\n", workflow.relative_path));
            }
        }
        out.push('\n');
    }

    // â”€â”€ Repository Overview â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    out.push_str("## ğŸ“‹ Repository Overview\n\n");

    // Project name and description from manifest_info (Python lines 135-139)
    if let Some(JsonValue::String(name)) = manifest_info.get("name") {
        out.push_str(&format!("**Project:** {}\n\n", name));
    }
    if let Some(JsonValue::String(description)) = manifest_info.get("description") {
        out.push_str(&format!("**Description:** {}\n\n", description));
    }

    // Language summary (top 5, bold paragraph â€” matches Python renderer.py lines 144-149)
    let mut lang_counts: Vec<_> = stats.languages_detected.iter().collect();
    lang_counts.sort_by(|a, b| b.1.cmp(a.1).then_with(|| a.0.cmp(b.0)));
    if !lang_counts.is_empty() {
        let top = lang_counts
            .iter()
            .take(5)
            .map(|(lang, count)| format!("{} ({})", lang, count))
            .collect::<Vec<_>>()
            .join(", ");
        out.push_str(&format!("\n**Languages:** {}\n\n", top));
    }

    // Entrypoints (sorted, non-indented bullets â€” matches Python renderer.py lines 152-156)
    let mut entrypoints: Vec<&str> = files
        .iter()
        .filter(|f| f.tags.contains("entrypoint"))
        .map(|f| f.relative_path.as_str())
        .collect();
    entrypoints.sort();
    if !entrypoints.is_empty() {
        out.push_str("\n**Entrypoints:**\n");
        for ep in entrypoints.iter().take(10) {
            out.push_str(&format!("- `{}`\n", ep));
        }
    }

    // Available Commands from package.json scripts (matches Python _render_overview lines 159-168)
    if let Some(JsonValue::Object(scripts)) = manifest_info.get("scripts") {
        let known_cmds = ["build", "test", "start", "dev", "lint"];
        let present: Vec<(&str, &str)> = known_cmds
            .iter()
            .filter_map(|cmd| scripts.get(*cmd).and_then(|v| v.as_str()).map(|val| (*cmd, val)))
            .collect();
        if !present.is_empty() {
            out.push_str("\n**Available Commands:**\n");
            for (cmd, val) in present {
                if val.len() > 60 {
                    out.push_str(&format!("- `{}`: `{}...`\n", cmd, &val[..60]));
                } else {
                    out.push_str(&format!("- `{}`: `{}`\n", cmd, val));
                }
            }
        }
    }

    // README excerpt â€” find the highest-priority readme file and show first 15 meaningful lines.
    // Matches Python renderer.py lines 170-190.
    if let Some(readme) = files.iter().find(|f| f.is_readme) {
        if let Ok((content, _)) = read_file_safe(&readme.path, Some(4000), None) {
            let readme_lines: Vec<&str> = content.lines().collect();
            let total_readme_lines = readme_lines.len();
            let mut excerpt_lines: Vec<&str> = Vec::new();
            let mut in_content = false;
            for line in readme_lines.iter().take(50) {
                let trimmed = line.trim();
                // Skip badges only before content begins (Python: badge check before in_content=True)
                if !in_content {
                    if trimmed.starts_with("![") || trimmed.starts_with("[![") {
                        continue;
                    }
                    if trimmed.is_empty() {
                        continue;
                    }
                    in_content = true;
                }
                excerpt_lines.push(line);
                if excerpt_lines.len() >= 15 {
                    break;
                }
            }
            if !excerpt_lines.is_empty() {
                let excerpt = excerpt_lines.join("\n");
                out.push_str(&format!("\n**README Excerpt:**\n\n{}\n", excerpt));
                if total_readme_lines > 50 {
                    out.push_str("\n*[README truncated...]*");
                }
            }
        }
    }
    out.push('\n');

    // â”€â”€ Directory Tree â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    out.push_str("## ğŸ“ Directory Structure\n\n");
    out.push_str("```\n");
    out.push_str(tree);
    out.push_str("\n```\n\n*â­ = Important file*\n\n");

    // â”€â”€ Key Files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Python groups into Documentation / Configuration / Entrypoints (5 per category).
    out.push_str("## ğŸ”‘ Key Files\n");

    #[allow(clippy::type_complexity)]
    let categories: &[(&str, Box<dyn Fn(&&FileInfo) -> bool>)] = &[
        ("Documentation", Box::new(|f: &&FileInfo| f.is_doc)),
        ("Configuration", Box::new(|f: &&FileInfo| f.is_config)),
        ("Entrypoints", Box::new(|f: &&FileInfo| f.tags.contains("entrypoint"))),
    ];

    for (category, predicate) in categories {
        let cat_files: Vec<&FileInfo> = files.iter().filter(|f| predicate(f)).take(5).collect();
        if !cat_files.is_empty() {
            out.push_str(&format!("\n### {}\n", category));
            for file in cat_files {
                let pct = (file.priority * 100.0).round() as u64;
                out.push_str(&format!("- `{}` ({}%)\n", file.relative_path, pct));
            }
        }
    }
    out.push('\n');

    // â”€â”€ Code Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Group files by language, skip pure text/markdown, top 5 languages.
    let mut files_by_lang: HashMap<&str, Vec<&FileInfo>> = HashMap::new();
    for file in files {
        files_by_lang.entry(file.language.as_str()).or_default().push(file);
    }
    let mut sorted_langs: Vec<_> = files_by_lang.iter().collect();
    sorted_langs.sort_by(|a, b| b.1.len().cmp(&a.1.len()).then_with(|| a.0.cmp(b.0)));

    let code_map_langs: Vec<_> = sorted_langs
        .iter()
        .filter(|(lang, _)| !matches!(**lang, "text" | "markdown"))
        .take(5)
        .collect();

    if !code_map_langs.is_empty() {
        out.push_str("## ğŸ—ºï¸ Code Map\n");
        for (lang, lang_files) in &code_map_langs {
            out.push_str(&format!("\n### {} ({} files)\n", capitalize(lang), lang_files.len()));

            // Group by directory
            let mut dirs: HashMap<String, Vec<&FileInfo>> = HashMap::new();
            for f in lang_files.iter() {
                let dir = Path::new(&f.relative_path)
                    .parent()
                    .and_then(|p| p.to_str())
                    .map(|s| if s.is_empty() { "(root)".to_string() } else { s.to_string() })
                    .unwrap_or_else(|| "(root)".to_string());
                dirs.entry(dir).or_default().push(f);
            }

            let mut sorted_dirs: Vec<_> = dirs.iter().collect();
            sorted_dirs.sort_by_key(|(d, _)| d.as_str());

            for (dir_path, dir_files) in sorted_dirs.iter().take(10) {
                out.push_str(&format!("\n**{}/**\n", dir_path));
                let mut sorted_files: Vec<&&FileInfo> = dir_files.iter().collect();
                sorted_files.sort_by_key(|f| {
                    Path::new(&f.relative_path)
                        .file_name()
                        .and_then(|n| n.to_str())
                        .unwrap_or("")
                        .to_string()
                });
                for f in sorted_files.iter().take(10) {
                    let fname = Path::new(&f.relative_path)
                        .file_name()
                        .and_then(|n| n.to_str())
                        .unwrap_or(&f.relative_path);
                    out.push_str(&format!("- `{}`\n", fname));
                }
                if dir_files.len() > 10 {
                    out.push_str(&format!("- *...and {} more*\n", dir_files.len() - 10));
                }
            }
        }
        out.push('\n');
    }

    // â”€â”€ File Contents â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    out.push_str("## ğŸ“„ File Contents\n\n");

    // Group chunks by file path, sorted by file priority then path.
    let file_priorities: HashMap<&str, f64> =
        files.iter().map(|f| (f.relative_path.as_str(), f.priority)).collect();
    let mut chunks_by_file: HashMap<&str, Vec<&Chunk>> = HashMap::new();
    for chunk in chunks {
        chunks_by_file.entry(chunk.path.as_str()).or_default().push(chunk);
    }

    let mut sorted_paths: Vec<&&str> = chunks_by_file.keys().collect();
    sorted_paths.sort_by(|a, b| {
        let pa = file_priorities.get(**a).copied().unwrap_or(0.0);
        let pb = file_priorities.get(**b).copied().unwrap_or(0.0);
        pb.partial_cmp(&pa).unwrap_or(std::cmp::Ordering::Equal).then_with(|| a.cmp(b))
    });

    for path in sorted_paths {
        let file_chunks = chunks_by_file.get(path).unwrap();
        let mut sorted_chunks: Vec<&&Chunk> = file_chunks.iter().collect();
        sorted_chunks.sort_by_key(|c| c.start_line);

        let lang = sorted_chunks.first().map(|c| c.language.as_str()).unwrap_or("text");
        let priority = file_priorities.get(*path).copied().unwrap_or(0.5);

        // Per-file header with metadata
        out.push_str(&format!("### `{}`\n\n", path));
        out.push_str(&format!(
            "*Priority: {:.0}% | Language: {} | Chunks: {}*\n\n",
            priority * 100.0,
            lang,
            file_chunks.len()
        ));

        for chunk in sorted_chunks {
            out.push_str(&format!("**Lines {}-{}:**\n\n", chunk.start_line, chunk.end_line));
            out.push_str(&format!("```{}\n", chunk.language));
            let trimmed = chunk.content.trim_end();
            out.push_str(trimmed);
            out.push('\n');
            out.push_str("```\n\n");
        }
    }

    out
}

fn capitalize(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
    }
}
